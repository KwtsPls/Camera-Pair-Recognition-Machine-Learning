# Project στο μάθημα Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα !!
# Mέλη της Ομάδας :
# 1. Κωνσταντίνος Πλας (1115201700125)
# 2. Ελευθέριος Στέτσικας (1115201700150)  
# Περιγραφή των δομών
## Dictionary.h
### Dictionary_node
Είναι μία δομή κόμβου λίστας η οποία χρησιμοποιείται για την αποθήκευση των .json αρχείων στην μνήμη. Γενικά ως `char *key` έχει δηλωθεί κάποιο από τα key του json αρχείου, και στο `char **value` αποθηκεύονται όλα τα values του key. Κρατάμε ακόμα έναν ακέραιο για να γνωρίζουμε πόσα διαφορετικά values μπορεί να έχει κάποιο **key**, `int values_num`. Και ακόμα υπάρχει ένας pointer `struct dict_node *next` που δείχνει στο επόμενο **Dictionary_node** για να αποθηκευτούν και τα υπόλοιπα **key** και **values** του json αρχείου. 
### Dictionary
Eίναι μία δομή στην οποία αποθηκεύουμε `char *dict_namε` το spec_id ενός αρχείου xxxx.json, π.χ. www.ebay.com//xxxx ,όπου αντιστοιχεί στον αριθμό του αρχείου xxxx.json, και ένα δείκτη σε μία λίστα `Dictionary_node *lista`για να αποθηκεύσουμε τα δεδομένα του αρχείου json.
### Functions
#### `Dictionary *initDictionary(char *dict_name)`
Η συνάρτηση αυτή δημιουργεί ένα αντικείμενο dictionary. Αρχικά, κάνει allocate στην μνήμη για το αντικείμενο. Έπειτα αντιγράφει το spec_id στο `Dictionary->dict_name`, χωρίς να αρχικοποιεί τη λίστα για το json αρχείο. Τέλος επιστρέφει το Dictionary που δημιούργησε.
#### `Dictionary *insertDictionary(Dictionary *dic, char *key, char **val, int num_val)`
Η συνάρτηση αυτή χρησιμοποιείται για να εισάγει ένα ζευγάρι key-value από το .json στο Dictionary. Αρχικά, ελέγχει αν το key υπάρχει ήδη μέσα στο Dictionary, αν υπάρχει απελευθερώνει τη μνήμη που είχε κατοχυρωθεί για τα val που ήταν να μπουν και επιστρέφει το παλιό **Dictionary**. Αλλιώς, δημιουργεί ένα καινούργιο κόμβο λίστας **Dictionary_node**, όπου δίνει τις αντίστοιχες τιμές που δέχεται η συνάρτηση ως παράμετρους στις αντίστοιχες μεταβλητές ενός **Dictionary_node**, τέλος ο `Dictionary_node->next` του καινούργιου κόμβου, δείχνει στο `dic->lista` και ο δείκτης λίστας του Dictionary dic δείχνει στον καινούργιο κόμβο, με άλλα λόγια ο καινούργιος κόμβος προστίθεται στην αρχή της λίστας του **dic**.
#### `int updateDictionary(Dictionary **dict,char *key, char **val, int num_val)`
Η συνάρτηση αυτή χρησιμοποιείται για την ανανέωση ενός παλιού key στο dictionary. Αρχικά προσπελάυνεται κάθε κόμβος της λίστας ξεχωριστά, μέχρι να βρεθεί ο κόμβος που αντιστοιχεί στο κλειδί key, που έχει δεχθεί ως παράμετρο η συνάρτηση. Αν βρεθεί το ίδιο κλείδι σε κάποιον κόμβο τότε διαγράφονται από την μνήμη τα παλιά του στοιχεία, και αντικαθαστόνται από τις αντίστοιχες παραμέτρους της συνάρτησης, ενώ στο τέλος επιστρέφεται η τιμή 1, όπου σημαίνει ότι ενημερώθηκε το παλιό dictionary_node. Αν δεν βρεθεί τότε επιστρέφει την τιμή -1, δηλαδή απέτυχε η ενημέρωση του κλειδιού key στην μνήμη.
#### `void printDictionary(Dictionary *dic)`
Η συνάρτηση αυτή χρησιμοποιείται για την εκτύπωση των στοιχείων ενός Dictionary. Τυπώνει πρώτα το spec_id *aka dict_name* και προσπελαύνει κάθε κόμβο της λίστας ξεχωριστά και εκτυπώνει τα key - value του κάθε κόμβου.
#### `char **lookUpDictionary(Dictionary *dic, char *key, int *num_val)`
Η συνάρτηση αυτή χρησιμοποιείται για να δούμε αν υπάρχει το key στο Dictionary dic, και αν υπάρχει επιστρέφει τον πίνακα values του.
#### `void deleteDictionary(Dictionary **dic)`
Η συνάρτηση αυτή χρησιμοποιείται για την σωστή απελευθέρωση του dictionary από την μνήμη. Προσπελαύνει κάθε κόμβο της λίστας διαγράφοντας κατάλληλα τα στοιχεία του, και τέλος απελευθερώνει τα δικά του στοιχεία `(*lista, dict_name)` και απελευθερώνεται και το αντικείμενο Dictionary.
#### `int sizeDictionary(Dictionary *dict)`
Η συνάρτηση αυτή επιστρέφει το μέγεθος ενός Dictionary, όπου είναι ο αριθμός των κόμβων της λίστας.
## Bucket.h
### Bucket
Είναι μια δομή κόμβου λίστας όπου χρησιμοποιείται για την υλοποίηση της δομής της κλίκας. Όπου στον array `Dictionary **spec_ids` αποθηκεύουμε τα spec_ids τα οποία ταιριάζουν σύμφωνα με το csv και αν δεν χωρέσουν στον array δημιουργείτε καινούργιος κόμβος λίστας για να περάσουμε τα υπόλοιπα `Dictionary **spec_ids` και ούτω καθεξής. Χρησιμοποιείται ο ακέραιος `int cnt` για την καταμέτρηση των περασμένων spec_ids στον πίνακα του κόμβου, ο ακέραιος `int numofSpecs` όπου μας δείχνει το μέγιστο αριθμό των spec_ids που χωράει ο πίνακας στον κόμβο.
### Bucketlist 
Είναι μια δομή λίστας όπου αποθηκεύονται όλα τα spec_ids του αρχείου που ταιριάζουν μεταξύ τους. Στον ακέραιο `int num_entries` αποθηκεύουμαι τον αριθμό των spec_ids που έχουν αποθηκευτεί. Τον χαρακτήρα `char dirty_bit` όπου χρησιμοποιείται ως flag για να γνωρίζουμε αν πρέπει να τυπώσουμε τα ζευγάρια της κλίκας που βρίσκονται στη λίστα ή όχι. Ακόμη υπάρχουν δύο δείκτες σε κόμβους λίστας, όπου ο ένας δείχνει στην κεφαλή και ο άλλος στο τέλος της, `struct Bucket *head` και `struct Bucket *tail`.
### Functions
#### `Bucket *Bucket_Create(Dictionary *spec_id, int BucketSize)`
Η συνάρτηση αυτή χρησιμοποιείται για τη δημιουργία ενός κόμβου λίστας, κάνοντας allocate τον κατάλληλο χώρο, και εισάγει το spec_id στον array των Dictionay για τα spec_ids. Το numofSpecs ορίζεται από το ΒucketSize.
#### `Bucket *Bucket_Insert(Bucket *buck, Dictionary *spec_id)`
Η συνάρτηση αυτή χρησιμοποιείται για να εισαχθεί ένα spec_id στον Dictionary array, αν όμως έχει γεμίσει ο array, τότε δημιουργείται καινούργιος κόμβος λίστας Bucket όπου εισάγεται στην αρχή της λίστας, ενώ ο δείκτης next του καινούργιου κόμβου δείχνει στην αρχική λίστα buck. Επιστρέφεται η ενημερωμένη λίστα.
#### `void Bucket_Delete(Bucket **DestroyIt,int mode)`
Η συνάρτηση αυτή χρησιμοποιείται για να διαγράψει το κόμβο της λίστας Bucket, η παράμετρος mode χρησιμοποιείται για να μην διαγραφούν από την μνήμη τα Dictionaries αν τα χρειάζομαστε, ενώ όταν φτάνουμε στο τέλος του προγράμματος διαγράφονται τα dictionaries από την μνήμη, μαζί με τον array τους και απελευθερώνεται ο χώρος που είχε δεσμευτεί από τον Bucket. 
#### `void Bucket_Print(Bucket *buck)`
Η συνάρτηση αυτή χρησιμοποιείται για να εκτυπώσει τα spec_ids που είναι μέσα στο Bucket.
#### `BucketList *BucketList_Create(Dictionary *spec_id, int BucketSize)`
Η συνάρτηση αυτή χρησιμοποιείται για να δημιουργήσει μία δομή BucketList. Δεσμεύει τον κατάλληλο χώρο για το BucketList, δημιουργεί τον πρώτο κόμβο της λίστας Bucket, αναθέτει κατάλληλα τους δείκτες της κεφαλής και της ουράς της λίστας, θέτει το dirty_bit σε 0 (μην το τυπώσεις) αφού περιέχει μία κλίκα και το num_entries σε 1.
#### `BucketList *BucketList_Insert(BucketList *buck, Dictionary *spec_id)`
Η συνάρτηση αυτή χρησιμοποιείται για να εισάγει ένα spec_id στη λίστα buck. Στην κεφαλή της λίστας χρησιμοποίειται η συνάρτηση Bucket_Insert και αυξάνεται ο αριθμός των num_entries.
#### `int BucketList_Bucket_Full(BucketList *bl)`
Η συνάρτηση αυτή επιστρέφει BUCKET_FIRST_FULL αν είναι γεμάτο ή BUCKET_FIRST_AVAILABLE αν υπάρχει χώρος.
#### `int BucketList_Empty(BucketList *b)`
Η συνάρτηση αυτή επιστρέφει LIST_EMPTY αν ο δείκτης κεφάλης της λίστας δείχνει σε ΝULL, αλλιώς επιστρέφει LIST_NOT_EMPTY.
#### `Dictionary *Bucket_Get_FirstEntry(BucketList *b)`
Η συνάρτηση αυτή επιστρέφει το πρώτο dictionary που υπάρχει στον πρώτο κόμβο της λίστας BucketList.
#### `void BucketList_Delete(BucketList **b, int mode)`
Η συνάρτηση αυτή χρησιμοποιείται για την διαγραφή της δομής BucketList και την κατάλληλη απελευθέρωση της μνήμης που έχει δεσμεύσει η δομή αυτή. Αρχικά ελέγχει αν η λίστα είναι NULL. Αυτό το ενδεχόμενο συμβαίνει διότι διαγράφονται όλοι οι κόμβοι του HashTable που περιέχουν τους δείκτες στη λίστα, και με την υλοποίηση μας μπορεί μία λίστα να έχει ήδη διαγραφεί. Επομένως αν υπάρχει τότε προσπελαύνεται κάθε κόμβος της λίστας ξεχωρίστα διαγράφεται ο κόμβος αυτός, ανάλογα και με το mode, και τέλος απελευθερώνεται και η μνήμη που έχει ανατεθεί στη λίστα BucketList.
#### `void BucketList_Print(BucketList *b)`
Η συνάρτηση αυτή χρησιμοποιείται για την εκτύπωση των spec_ids των κόμβων της λίστας.
#### `BucketList *BucketList_Delete_First(BucketList **b,int mode)`
H συνάρτηση αυτή χρησιμοποιείται για διαγράψει τον πρώτο κόμβο της λίστας b. Αν υπάρχει ένας κόμβος τότε διαγράφεται κανονικά και επιστρέφεται ΝULL. Αλλιώς διαγράφεται ο πρώτος κόμβος κανονικά, και αναθέτουμε τον δείκτη του κόμβου κεφαλής στον επόμενο κόμβο από αυτόν που διαγράψαμε. Τέλος επιστρέφεται η λίστα b χωρίς τον αρχικό της κόμβο.
#### `void bucketListWriteCliques(BucketList *lista, FILE *fp)`
Η συνάρτηση αυτή χρησιμοποιείται για να προσπελαύσει κάθε στοιχείο της λίστας lista και να τα τυπώσει στο αρχείο fp. Ξεκινώντας από το πρώτο αντικείμενο Dictionary της λίστας το θεωρούμε ως left_spec_id, εν συνέχεια προπελάυνουμε τα υπόλοιπα στοιχεία της λίστας, ένα-ένα τα θεώρουμε right_spec, τα τυπώνουμε στο αρχείο, συνεχίζουμε στο βρόγχο εώς ότου left_spec_id γίνουν όλα τα αντικείμενα της λίστας πέρα από το τελευταίο. Έτσι ώστε κάθε ζευγάρι κλίκας να τυπωθεί ακριβώς μία φόρα.
### HashTable.h
#### keyBucketEntry
Η δομή αυτή περιέχει ένα ξεχωριστό spec_id ως `char *key` και μία λίστα `BucketList *set` όπου περιέχει όλες τα υπόλοιπα spec_ids που ταιριάζει το key.
#### keyBucket
Η δομή αυτή περιέχει ένα `int bucket_size` που καταχωρύται το μέγεθος του Bucket σε bytes, τα `int num_entries` όπου είναι ο αριθμός των καταχωρυμένων keyBucketEntry στον array `keyBucketEntry **array` και `int max_entries` όπου είναι ο αριθμός των keyBucketEntry που μπορούν να καταχωρυθούν στον array.
#### HashTable
Η δομή αυτή είναι ένα HashTable το οποίο αναδιαμορφώνει το μέγεθος του και το διπλασιάζει όταν δεν υπάρχει χώρος σε ένα bucket. Ως `int bucket_num` καταχωρούνται ο μέγιστος αριθμός buckets που μπορεί να έχει το Table. Και ως `keyBucket **table` είναι ο array που περιέχει τα στοιχεία του HashTable, στη θέση μνήμης που έχει υποδείξει η HashFuction.
#### Functions
#### `unsigned long hashCode(char *,int)`
Αυτή η συνάρτηση χρησιμοποιείται για να hash-άρει τα spec_ids και επιστρέφει τη θέση τους στον πίνακα.
#### `keyBucket *initKeyBucket(Dictionary *spec_id)`
Η συνάρτηση χρησιμοποιείται για να δημιουργήσουμε μια δομή keyBucket. Δεσμεύεται η κατάλληλη μνήμη, αρχικοποιούνται κατάλληλα τα στοιχεία της, και δημιουργείται το πρώτο keyBucketEntry στη θέση 0 του array, αφού έχει δεσμευτεί η μνήμη και έχει δημιουργηθεί ο πίνακας με αριθμό στοιχείων max_entries. Όλα τα στοιχεία του array δείχνουν σε NULL εκτός από το πρώτο, που δείχνει στο νέο μας KeyBucketEntry.
#### `int keyBucketAvailable(keyBucket *kb)`
Η συνάρτηση ελέγχει αν στο keyBucket kb υπάρχει χώρος. Αν δηλαδή τα max_entries είναι ίσα με τα num_entries. Επιστρέφει **KEY_BUCKET_FULL** αν ισχύει, αλλιώς **KEY_BUCKET_AVAILABLE**.
#### `keyBucketEntry *createEntry(Dictionary *dict)`
H συνάρτηση αυτή δεσμεύει τον χώρο κατάλληλα για να δημιουργηθεί ενα αντικείμενο keyBucketEntry. Αρχικοποιεί κατάλληλα κάθε μεταβλητή του keyBucketEntry, δημιουργώντας και τη λίστα BucketList όπου αποθηκεύεται το Dictionary dict.
#### `keyBucket *insertBucketEntry(keyBucket *kb,Dictionary *spec_id)`
Η συνάρτηση αυτή εισάγει ένα καινούργιο spec_id στη δομή, δημιουργώντας ένα ανιτκείμενο στο keyBucketEntry στο πρώτο άδειο κελί του πίνακα και αυξάνει τον αριθμό των num_entries της δομής.
#### `Dictionary *getTopKeyBucketEntry(keyBucket *kb, int pos)`
Επιστρέφει το πρώτο αντικείμενο της λίστας BucketList, από το keyBucketEntry που δείχνει ο πίνακας του keyBucket kb στη θέση pos.
#### `HashTable *reshapeHashTable(HashTable **ht,Dictionary *spec_id)`
Η συνάρτηση αυτή αναδιαμορφώνει το μέγεθος του HashTable στο διπλάσιο του. Αρχικά δημιούργειται ένα νέο HashTable, με το διπλάσιο μέγεθος από το παλιό. Έπειτα προσπελαύνεται κάθε κελί του παλιού HashTable και λαμβάνει όλα τα ήδη αποθηκευμένα Dictioanry και τα ξαναπερνάει στο καινούργιο HashTable. Έπειτα περνάει το spec_id που έκανε το collision και διαγράφει το παλιό hashTable, χωρίς να διαγράψει τα dictionary. Επιστρέφεται το καινούργιο HashTable με το διπλάσιο μέγεθος.
#### `HashTable *initHashTable(int buckets_num)`
Η συνάρτηση αυτή δεσμεύει χώρο στη μνήμη για να δημιουργήσει μια δομή HashTable, αρχικοποιεί κατάλληλα τα στοιχεία της και επιστρέφει το αντικείμενο HashTable, buckets_num είναι ο αριθμός των κελιών του, ενώ το bucketSize το έχουμε κάνει define.
#### `HashTable *insertHashTable(HashTable **ht,Dictionary *spec_id)`
Η συνάρτηση αυτή hasharei το spec_id, και το αποθηκεύει στο HashTable. Αν το bucket που επιστρέφεται από την Hash Function είναι γεμάτο τότε καλείται η reshapeHashTable() για να γίνει αναδιαμόρφωση του HashTable, έτσι ώστε να υπάρχει χώρος. Αλλιώς 
αν το Bucket υπάρχει τότε το αποθηκεύουμαι στο Bucket, αν δεν υπάρχει τότε δημιουργούμε το Bucket.
#### `int sizeHashTable(HashTable *ht)`
Η συνάρτηση αυτή αθροίζει διαδοχικά τα Num_entries των buckets που υπάρχουν στο HashTable και επιτρέφει τον ακέραιο που υπολόγισε.
#### `int findKeyBucketEntry(HashTable *ht,char * spec_id)`
Η συνάρτηση αυτή hasharei την τιμή του spec_id βρίσκει τον αριθμό σε ποιο κελί του HashTable βρίσκεται και επιστρέφει σε ποιο σημείο του κελιού βρίσκεται η τιμή spec_id. Αν το κελί δεν υπάρχει ή το spec_id τότε επιστρέφεται η τιμή -1.
#### `void deleteHashTable(HashTable **destroyed,int mode)`
H συνάρτηση αυτή απελευθερώνει τη μνήμη, που έχει δεσμευτεί για το HashTable. Προσπελαύνει κάθε κελί του και αν υπάρχει διαγράφεται από τη μνήμη, έπειτα απελευθερώνεται ο πίνακας και τέλος το HashTable.
#### `void cliqueDeleteHashTable(HashTable **ht,int mode)`
Η συνάρτηση αυτή χρησιμοποιείται για την διαγραφή του HashTable, αφ'ότου οι κλίκες έχουν δημιουργηθεί. Ουσιαστικά αυτή η συνάρτηση προσπελαύνει κάθε κέλι του Bucket, και από εκεί προσπελαύνεται κάθε στοιχείο του array του, και ελέγχεται αν η λίστα που δείχνει keyBucketEntry έχει αποθηκευμένες περισσότερες από μία κλίκες, αν όχι τότε διαγράφεται από την μνήμη. Αν ναι τότε βρίσκονται όλα τα keyBucketEntry -> set που δείχνουν σε αυτή τη κλίκα και το set τους γίνεται ΝULL, έπειτα διαγράφεται η λίστα. Διαγράφονται κανονικά τα υπόλοιπα στοιχεία του HashTable, και τέλος το HashTable. 
#### `HashTable *erasePointerHashTable(HashTable **ht,keyBucketEntry *clique_bucket)`
Η συνάρτηση αυτή χρησιμοποιείται για να αναθέσει όλου τους δείκτες σε μία κλίκα την τιμή NULL, έτσι ώστε η κλίκα να διαγραφεί επιτυχώς. Προσπελαύνει ξεχωριστά τους κόμβους της λίστας set, γίνεται χρήση των συναρτήσεων hashCode() και findKeyBucketEntry() για να βρεθεί η θέση του pointer set του κάθε κόμβου στο HashTable και να τον θέσουμε σε ΝULL.
#### `void deleteKeyBucket(keyBucket **destroyed,int mode)`
Η συνάρτηση αυτή απελευθερώνει κατάλληλα τον χώρο που έχει δεσμευτεί από την δημιουργία της δομής keyBucket. Προσπελαύνει τα στοιχεία του πίνακα, και αν υπάρχουν τα διαγράφει, έπειτα διαγράφει τον πίνακα και τέλος το keyBucket.
#### `void printHashTable(HashTable *ht)`
Η συνάρτηση αυτή χρησιμοποιείται για να τυπώσει τα στοιχεία ενός HashTable.
#### `HashTable *createCliqueHashTable(HashTable **ht, char *left_sp,char *right_sp)`
Αυτή η συνάρτηση χρησιμοποιείται για να δημιουργήσει τις κλίκες στο HashTable. Αρχικά βρίσκονται οι θέσεις των left_spec και right_spec στο HashTable, ελέγχεται αν δεν έχουν ήδη καταχωρυθεί επαγωγικά στην ίδια λίστα, κοιτάμε πιο έχει τα περισσότερα num_entries. Επιλέγουμε αυτό που έχει τα λίγοτερα και αλλάζουμε τους δείκτες των στοιχείων που είναι κλίκες με αυτό να δείχνουν στην καινούργια λίστα changePointerHashTable() που θα γίνει με το BukcetListMerge(). Έπειτα γίνεται το ΒucketListMerge() των δύο λιστών και επιστρέφεται ανανεωμένο το HashTable.
#### `HashTable *changePointerHashTable(HashTable **ht,keyBucketEntry *old_bucket,keyBucketEntry *new_bucket)`
Η συνάρτηση αυτή χρησιμοποιείται για να αλλάξουμε σωστά τους δείκτες στην νέα λίστα που θα διαμορφωθεί από το merge. Προσπελαύνουμε όλα τα στοιχεία που βρίσκονται στην clique_bucket βρίσκουμε τις θέσεις τους στο HashTable και ο δείκτης της λίστας τους set αλλάζει και ορίζεται να δείχνει εκεί που θα βρίσκεται η merged List. Κατα τη διάρκεια του βρόγχου παρακάμπτεται το old_bucket και δεν αλλάζουμε τον δείκτη του.
#### `BucketList *BucketList_Merge(BucketList **Max_List, BucketList **min_List,HashTable **ht,int h,int index)`
Η συνάρτηση αυτή ενώνει δύο διαφορετικές λίστες μεταξύ τους. Στην μία περίπτωση, όπου η λίστα που min_List (η λίστα με τα λιγότερα num_entries) είναι γεμάτος ο κόμβος της κεφαλής της, προστίθεται στο τέλος της Max_list απελευθερώνεται ο χώρος που είχε δεσμευτεί από το δείκτη της min_list, το hashTable δείχνει σωστά στη νέα λίστα και επιστρέφεται η λίστα. Αλλιώς προσπελαύνεται κάθε στοιχείο της κεφαλής min_list και προστίθεται στη Max_List. Ο πρώτος κόμβος της min_list διαγράφεται. Αν η min_list άδειασε διαγράφουμε την υπόλοιπη λίστα θέτουμε τους δείκτες του HashTable να δείχνουν σωστά και επιστρέφουμε τη λίστα. Αλλιώς κάνουμε το ίδιο που κάναμε στην αρχική μας περίπτωση αφού τώρα θα έχουμε μία γεμάτη min_list.
# Υπόλοιπες συναρτήσεις
## CsvReader.h
#### `HashTable *csvParser(char *filename, HashTable **ht)`
Αυτή η συνάρτηση parsa - ρει τις κλίκες από το filename. Διαβάζοντας κάθε γραμμή, τη σπάει σε 3 στοιχεία από το ',' και αν το 3ο είναι 1 τότε περνάει την κλίκα στο HashTable με την συνάρτηση createCliqueHashTable() τέλος κλείνει το αρχείο που άνοιξε και αποδεσμεύει την μνήμη που δέσμευσε. Επιστρέφει το HashTable που δημιούργησε.
#### `void csvWriteCliques(HashTable **ht)`
Αυτή η συνάρτηση χρεισημοποείται για να δημιουργήσει ένα αρχείο *cliques.csv* και να εκτυπώσει όλες τις κλίκες που υπάρχουν στο HashTable προσπελαύνοντας το και εκτυπώνοντας μία φορά τα ζεύγη στη μορφή *left_spec_id,right_spec_id*
## JsonParser.h
#### `char *get_datasetX_name()`
Η συνάρτηση αυτή προσπελαύνει όλα τα αρχεία στον τοπικό φάκελο και βρίσκει αυτό που περιέχει τα datasets. Αυτό γίνεται αφού ανοίγει τους υποφακέλους μέχρι να βρει το αρχείο που θα έχει format xxxx.json και επιστρέφει το path του αρχείου αυτού. 
#### `int Initialize_dataset_X(char *name,HashTable **ht)`
H συνάρτηση αυτή χρησιμοποιείται για να φτιάξει τις πρώτες κλίκες του HashTable. Αυτό γίνεται προσπελαύνοντας όλους του υποφακέλους του dataset_X, και επαναλαμβάνεται ένας βρόγχος ο οποίος προσπελαύνει τα αρχεία του υποφακέλου και τα parsa-ρει και τα αποθηκεύει στο HashTable ht με τη συνάρτηση parse_json_file(). Αν όλα πήγαν καλά επιστρέφεται 1, -1 αν κάτι έγινε λάθος.
#### `void parse_json_file(char *name,char* spec_id,HashTable **ht)` 
H συνάρτηση αναλύει το json file που άνοιξε σε keys - values. Ότι είναι αριστερά από το χαρακτήρα ':' είναι key. Και το key μπορεί να έχει κάποιους χαρακτήρες ("/ "") που δεν θέλουμε να λάβουμε υπ'όψιν. Έπειτα ελέγχουμε αν το value δεν έχει παραπάνω από ένα στοιχείο, αφαιρούμε τους περιττούς χαρακτήρες, και δημιουργούμε το dictionary που δημιουργήσαμε για το spce_id. Αλλιώς μετράμε τις γραμμές που μπορεί να έχουν τα values, μέχρι να φτάσουμε στο χαρατκήρα ']' δημιουργούμε έναν πίνακα με τα values και τα αποθηκεύουμε στο dictionary. Όλοι αυτή η διαδικασία επαναλαμβάνεται για κάθε γραμή key - value του .json αρχείου. Όταν τελειώσει η ανάγνωση του αρχείου τότε εισάγουμε το ολοκληρωμένο dictionary στο HashTable μας απελευθερώνουμε κατάλληλα τη δεσμευμένη μνήμη.
## main.c
Η main βρίσκει σε ποιο σημείο βρίσκεται το αρχείο των data. Δημιουργεί το HashTable που πρέπει να αποθηκεύσει τις κλίκες. Περνάει για πρώτη φορά τις κλίκες από το dataset_X. Έπειτα διαβάζει το αρχείο του csv και δημιουργεί τις υπόλοιπες κλίκες. Τέλος γράφει τις κλίκες σε ένα άλλο αρχείο, και απελευθερώνει κατάλληλα τη μνήμη.
# ErrorHandling
1. Αν δεν ανοίξει ο φάκελος, και έχει αποτύχει η opendir()
2. Αν δεν βρεθεί το αρχείο dataset_X
3. Aν δεν ανοίξει σωστά κάποιο JSON
4. Αν αποτύχει η malloc()
5. Αν αποτύχει να ανοίξει κάποιο αρχείο
6. Αν αποτύχει να γράψει σε κάποιο αρχείο
# Χρήσιμες εντολές
### make - Για να δημιουργηθεί η main
### make test - Για να δημιουργηθούν τα test cases του accutest
### ./test - Για τα test files
### ./main - Για να τρέξει η main
### make clean - Για να σβηστούν τα .o και εκτελέσιμα
