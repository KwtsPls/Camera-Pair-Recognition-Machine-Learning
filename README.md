# Project στο μάθημα Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα !!
# Mέλη της Ομάδας :
# 1. Κωνσταντίνος Πλας (1115201700125)
# 2. Ελευθέριος Στέτσικας (1115201700150)  
# Περιγραφή των δομών
## Dictionary.h
### Dictionary_node
Είναι μία δομή κόμβου λίστας η οποία χρησιμοποιείται για την αποθήκευση των .json αρχείων στην μνήμη. Γενικά ως `char *key` έχει δηλωθεί κάποιο από τα key του json αρχείου, και στο `char **value` αποθηκεύονται όλα τα values του key. Κρατάμε ακόμα έναν ακέραιο για να γνωρίζουμε πόσα διαφορετικά values μπορεί να έχει κάποιο **key**, `int values_num`. Και ακόμα υπάρχει ένας pointer `struct dict_node *next` που δείχνει στο επόμενο **Dictionary_node** για να αποθηκευτούν και τα υπόλοιπα **key** και **values** του json αρχείου. 
### Dictionary
Eίναι μία δομή στην οποία αποθηκεύουμε `char *dict_namε` το spec_id ενός αρχείου xxxx.json, π.χ. www.ebay.com//xxxx ,όπου αντιστοιχεί στον αριθμό του αρχείου xxxx.json, και ένα δείκτη σε μία λίστα `Dictionary_node *lista`για να αποθηκεύσουμε τα δεδομένα του αρχείου json.
### Functions
#### `Dictionary *initDictionary(char *dict_name)`
Η συνάρτηση αυτή δημιουργεί ένα αντικείμενο dictionary. Αρχικά, κάνει allocate στην μνήμη για το αντικείμενο. Έπειτα αντιγράφει το spec_id στο `Dictionary->dict_name`, χωρίς να αρχικοποιεί τη λίστα για το json αρχείο. Τέλος επιστρέφει το Dictionary που δημιούργησε.
#### `Dictionary *insertDictionary(Dictionary *dic, char *key, char **val, int num_val)`
Η συνάρτηση αυτή χρησιμοποιείται για να εισάγει ένα ζευγάρι key-value από το .json στο Dictionary. Αρχικά, ελέγχει αν το key υπάρχει ήδη μέσα στο Dictionary, αν υπάρχει απελευθερώνει τη μνήμη που είχε κατοχυρωθεί για τα val που ήταν να μπουν και επιστρέφει το παλιό **Dictionary**. Αλλιώς, δημιουργεί ένα καινούργιο κόμβο λίστας **Dictionary_node**, όπου δίνει τις αντίστοιχες τιμές που δέχεται η συνάρτηση ως παράμετρους στις αντίστοιχες μεταβλητές ενός **Dictionary_node**, τέλος ο `Dictionary_node->next` του καινούργιου κόμβου, δείχνει στο `dic->lista` και ο δείκτης λίστας του Dictionary dic δείχνει στον καινούργιο κόμβο, με άλλα λόγια ο καινούργιος κόμβος προστίθεται στην αρχή της λίστας του **dic**.
#### `int updateDictionary(Dictionary **dict,char *key, char **val, int num_val)`
Η συνάρτηση αυτή χρησιμοποιείται για την ανανέωση ενός παλιού key στο dictionary. Αρχικά προσπελάυνεται κάθε κόμβος της λίστας ξεχωριστά, μέχρι να βρεθεί ο κόμβος που αντιστοιχεί στο κλειδί key, που έχει δεχθεί ως παράμετρο η συνάρτηση. Αν βρεθεί το ίδιο κλείδι σε κάποιον κόμβο τότε διαγράφονται από την μνήμη τα παλιά του στοιχεία, και αντικαθαστόνται από τις αντίστοιχες παραμέτρους της συνάρτησης, ενώ στο τέλος επιστρέφεται η τιμή 1, όπου σημαίνει ότι ενημερώθηκε το παλιό dictionary_node. Αν δεν βρεθεί τότε επιστρέφει την τιμή -1, δηλαδή απέτυχε η ενημέρωση του κλειδιού key στην μνήμη.
#### `void printDictionary(Dictionary *dic)`
Η συνάρτηση αυτή χρησιμοποιείται για την εκτύπωση των στοιχείων ενός Dictionary. Τυπώνει πρώτα το spec_id *aka dict_name* και προσπελαύνει κάθε κόμβο της λίστας ξεχωριστά και εκτυπώνει τα key - value του κάθε κόμβου.
#### `char **lookUpDictionary(Dictionary *dic, char *key, int *num_val)`
Η συνάρτηση αυτή χρησιμοποιείται για να δούμε αν υπάρχει το key στο Dictionary dic, και αν υπάρχει επιστρέφει τον πίνακα values του.
#### `void deleteDictionary(Dictionary **dic)`
Η συνάρτηση αυτή χρησιμοποιείται για την σωστή απελευθέρωση του dictionary από την μνήμη. Προσπελαύνει κάθε κόμβο της λίστας διαγράφοντας κατάλληλα τα στοιχεία του, και τέλος απελευθερώνει τα δικά του στοιχεία `(*lista, dict_name)` και απελευθερώνεται και το αντικείμενο Dictionary.
#### `int sizeDictionary(Dictionary *dict)`
Η συνάρτηση αυτή επιστρέφει το μέγεθος ενός Dictionary, όπου είναι ο αριθμός των κόμβων της λίστας.
## Bucket.h
### Bucket
Είναι μια δομή κόμβου λίστας όπου χρησιμοποιείται για την υλοποίηση της δομής της κλίκας. Όπου στον array `Dictionary **spec_ids` αποθηκεύουμε τα spec_ids τα οποία ταιριάζουν σύμφωνα με το csv και αν δεν χωρέσουν στον array δημιουργείτε καινούργιος κόμβος λίστας για να περάσουμε τα υπόλοιπα `Dictionary **spec_ids` και ούτω καθεξής. Χρησιμοποιείται ο ακέραιος `int cnt` για την καταμέτρηση των περασμένων spec_ids στον πίνακα του κόμβου, ο ακέραιος `int numofSpecs` όπου μας δείχνει το μέγιστο αριθμό των spec_ids που χωράει ο πίνακας στον κόμβο.
### Bucketlist 
Είναι μια δομή λίστας όπου αποθηκεύονται όλα τα spec_ids του αρχείου που ταιριάζουν μεταξύ τους. Στον ακέραιο `int num_entries` αποθηκεύουμαι τον αριθμό των spec_ids που έχουν αποθηκευτεί. Τον χαρακτήρα `char dirty_bit` όπου χρησιμοποιείται ως flag για να γνωρίζουμε αν πρέπει να τυπώσουμε τα ζευγάρια της κλίκας που βρίσκονται στη λίστα ή όχι. Ακόμη υπάρχουν δύο δείκτες σε κόμβους λίστας, όπου ο ένας δείχνει στην κεφαλή και ο άλλος στο τέλος της, `struct Bucket *head` και `struct Bucket *tail`.
### Functions
#### `Bucket *Bucket_Create(Dictionary *spec_id, int BucketSize)`
Η συνάρτηση αυτή χρησιμοποιείται για τη δημιουργία ενός κόμβου λίστας, κάνοντας allocate τον κατάλληλο χώρο, και εισάγει το spec_id στον array των Dictionay για τα spec_ids. Το numofSpecs ορίζεται από το ΒucketSize.
#### `Bucket *Bucket_Insert(Bucket *buck, Dictionary *spec_id)`
Η συνάρτηση αυτή χρησιμοποιείται για να εισαχθεί ένα spec_id στον Dictionary array, αν όμως έχει γεμίσει ο array, τότε δημιουργείται καινούργιος κόμβος λίστας Bucket όπου εισάγεται στην αρχή της λίστας, ενώ ο δείκτης next του καινούργιου κόμβου δείχνει στην αρχική λίστα buck. Επιστρέφεται η ενημερωμένη λίστα.
#### `void Bucket_Delete(Bucket **DestroyIt,int mode)`
Η συνάρτηση αυτή χρησιμοποιείται για να διαγράψει το κόμβο της λίστας Bucket, η παράμετρος mode χρησιμοποιείται για να μην διαγραφούν από την μνήμη τα Dictionaries αν τα χρειάζομαστε, ενώ όταν φτάνουμε στο τέλος του προγράμματος διαγράφονται τα dictionaries από την μνήμη, μαζί με τον array τους και απελευθερώνεται ο χώρος που είχε δεσμευτεί από τον Bucket. 
#### `void Bucket_Print(Bucket *buck)`
Η συνάρτηση αυτή χρησιμοποιείται για να εκτυπώσει τα spec_ids που είναι μέσα στο Bucket.
#### `BucketList *BucketList_Create(Dictionary *spec_id, int BucketSize)`
Η συνάρτηση αυτή χρησιμοποιείται για να δημιουργήσει μία δομή BucketList. Δεσμεύει τον κατάλληλο χώρο για το BucketList, δημιουργεί τον πρώτο κόμβο της λίστας Bucket, αναθέτει κατάλληλα τους δείκτες της κεφαλής και της ουράς της λίστας, θέτει το dirty_bit σε 0 (μην το τυπώσεις) αφού περιέχει μία κλίκα και το num_entries σε 1.
#### `BucketList *BucketList_Insert(BucketList *buck, Dictionary *spec_id)`
Η συνάρτηση αυτή χρησιμοποιείται για να εισάγει ένα spec_id στη λίστα buck. Στην κεφαλή της λίστας χρησιμοποίειται η συνάρτηση Bucket_Insert και αυξάνεται ο αριθμός των num_entries.
#### `int BucketList_Bucket_Full(BucketList *bl)`
Η συνάρτηση αυτή επιστρέφει BUCKET_FIRST_FULL αν είναι γεμάτο ή BUCKET_FIRST_AVAILABLE αν υπάρχει χώρος.
#### `int BucketList_Empty(BucketList *b)`
Η συνάρτηση αυτή επιστρέφει LIST_EMPTY αν ο δείκτης κεφάλης της λίστας δείχνει σε ΝULL, αλλιώς επιστρέφει LIST_NOT_EMPTY.
#### `Dictionary *Bucket_Get_FirstEntry(BucketList *b)`
Η συνάρτηση αυτή επιστρέφει το πρώτο dictionary που υπάρχει στον πρώτο κόμβο της λίστας BucketList.
#### `void BucketList_Delete(BucketList **b, int mode)`
Η συνάρτηση αυτή χρησιμοποιείται για την διαγραφή της δομής BucketList και την κατάλληλη απελευθέρωση της μνήμης που έχει δεσμεύσει η δομή αυτή. Αρχικά ελέγχει αν η λίστα είναι NULL. Αυτό το ενδεχόμενο συμβαίνει διότι διαγράφονται όλοι οι κόμβοι του HashTable που περιέχουν τους δείκτες στη λίστα, και με την υλοποίηση μας μπορεί μία λίστα να έχει ήδη διαγραφεί. Επομένως αν υπάρχει τότε προσπελαύνεται κάθε κόμβος της λίστας ξεχωρίστα διαγράφεται ο κόμβος αυτός, ανάλογα και με το mode, και τέλος απελευθερώνεται και η μνήμη που έχει ανατεθεί στη λίστα BucketList.
#### `void BucketList_Print(BucketList *b)`
Η συνάρτηση αυτή χρησιμοποιείται για την εκτύπωση των spec_ids των κόμβων της λίστας.
#### `BucketList *BucketList_Delete_First(BucketList **b,int mode)`
H συνάρτηση αυτή χρησιμοποιείται για διαγράψει τον πρώτο κόμβο της λίστας b. Αν υπάρχει ένας κόμβος τότε διαγράφεται κανονικά και επιστρέφεται ΝULL. Αλλιώς διαγράφεται ο πρώτος κόμβος κανονικά, και αναθέτουμε τον δείκτη του κόμβου κεφαλής στον επόμενο κόμβο από αυτόν που διαγράψαμε. Τέλος επιστρέφεται η λίστα b χωρίς τον αρχικό της κόμβο.
#### `void bucketListWriteCliques(BucketList *lista, FILE *fp)`
Η συνάρτηση αυτή χρησιμοποιείται για να προσπελαύσει κάθε στοιχείο της λίστας lista και να τα τυπώσει στο αρχείο fp. Ξεκινώντας από το πρώτο αντικείμενο Dictionary της λίστας το θεωρούμε ως left_spec_id, εν συνέχεια προπελάυνουμε τα υπόλοιπα στοιχεία της λίστας, ένα-ένα τα θεώρουμε right_spec, τα τυπώνουμε στο αρχείο, συνεχίζουμε στο βρόγχο εώς ότου left_spec_id γίνουν όλα τα αντικείμενα της λίστας πέρα από το τελευταίο. Έτσι ώστε κάθε ζευγάρι κλίκας να τυπωθεί ακριβώς μία φόρα.
